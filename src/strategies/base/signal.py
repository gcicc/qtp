"""
Signal definitions and utilities.

Defines the Signal class and related enums for representing trading signals
generated by strategies. Signals contain all information needed for trade execution.
"""

from datetime import datetime
from enum import Enum
from typing import Optional, Dict, Any
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)


class SignalType(Enum):
    """
    Enumeration of signal types.
    
    Defines the basic action types that a trading signal can represent.
    """
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    EXIT_LONG = "exit_long"
    EXIT_SHORT = "exit_short"


class SignalStrength(Enum):
    """
    Enumeration of signal strength levels.
    
    Indicates the confidence or strength of a trading signal to help
    with position sizing and risk management decisions.
    """
    WEAK = 1
    MODERATE = 2
    STRONG = 3
    VERY_STRONG = 4


@dataclass
class Signal:
    """
    Represents a trading signal generated by a strategy.
    
    Contains all information necessary to execute a trade including
    the action, symbol, timing, and associated metadata.
    """
    
    # Core signal information
    symbol: str                                 # Trading symbol (e.g., "AAPL")
    signal_type: SignalType                     # Type of signal (buy, sell, etc.)
    timestamp: datetime                         # When the signal was generated
    price: float                               # Reference price for the signal
    
    # Position and risk information
    position_size: float                       # Recommended position size
    confidence: float                          # Confidence score (0-1)
    strength: SignalStrength = SignalStrength.MODERATE
    
    # Optional execution parameters
    stop_loss: Optional[float] = None          # Stop loss price
    take_profit: Optional[float] = None        # Take profit price
    expiry: Optional[datetime] = None          # Signal expiration time
    
    # Strategy and context information
    strategy_name: str = ""                    # Name of generating strategy
    reason: str = ""                           # Human-readable reason for signal
    metadata: Dict[str, Any] = None            # Additional strategy-specific data
    
    # Execution tracking
    is_executed: bool = False                  # Whether signal has been executed
    execution_price: Optional[float] = None    # Actual execution price
    execution_time: Optional[datetime] = None  # Actual execution timestamp
    
    def __post_init__(self):
        """Initialize default values after object creation."""
        if self.metadata is None:
            self.metadata = {}
        
        # Validate core fields
        self._validate_signal()
    
    def _validate_signal(self) -> None:
        """Validate signal parameters for consistency."""
        if self.position_size == 0 and self.signal_type in [SignalType.BUY, SignalType.SELL]:
            logger.warning(f"Zero position size for {self.signal_type} signal on {self.symbol}")
        
        if not 0 <= self.confidence <= 1:
            raise ValueError(f"Confidence must be between 0 and 1, got {self.confidence}")
        
        if self.price <= 0:
            raise ValueError(f"Price must be positive, got {self.price}")
        
        if self.stop_loss and self.stop_loss <= 0:
            raise ValueError(f"Stop loss must be positive, got {self.stop_loss}")
        
        if self.take_profit and self.take_profit <= 0:
            raise ValueError(f"Take profit must be positive, got {self.take_profit}")
    
    def is_buy_signal(self) -> bool:
        """Check if this is a buy signal."""
        return self.signal_type == SignalType.BUY
    
    def is_sell_signal(self) -> bool:
        """Check if this is a sell signal."""
        return self.signal_type == SignalType.SELL
    
    def is_exit_signal(self) -> bool:
        """Check if this is an exit signal."""
        return self.signal_type in [SignalType.EXIT_LONG, SignalType.EXIT_SHORT]
    
    def is_hold_signal(self) -> bool:
        """Check if this is a hold signal."""
        return self.signal_type == SignalType.HOLD
    
    def is_expired(self, current_time: datetime) -> bool:
        """
        Check if the signal has expired.
        
        Args:
            current_time: Current timestamp to check against
            
        Returns:
            True if signal has expired, False otherwise
        """
        if self.expiry is None:
            return False
        return current_time > self.expiry
    
    def get_expected_return(self) -> Optional[float]:
        """
        Calculate expected return if take profit is set.
        
        Returns:
            Expected return as a percentage, or None if take profit not set
        """
        if self.take_profit is None:
            return None
        
        if self.is_buy_signal():
            return ((self.take_profit - self.price) / self.price) * 100
        elif self.is_sell_signal():
            return ((self.price - self.take_profit) / self.price) * 100
        
        return None
    
    def get_risk(self) -> Optional[float]:
        """
        Calculate risk if stop loss is set.
        
        Returns:
            Risk as a percentage, or None if stop loss not set
        """
        if self.stop_loss is None:
            return None
        
        if self.is_buy_signal():
            return ((self.price - self.stop_loss) / self.price) * 100
        elif self.is_sell_signal():
            return ((self.stop_loss - self.price) / self.price) * 100
        
        return None
    
    def get_risk_reward_ratio(self) -> Optional[float]:
        """
        Calculate risk-reward ratio.
        
        Returns:
            Risk-reward ratio, or None if stop loss or take profit not set
        """
        expected_return = self.get_expected_return()
        risk = self.get_risk()
        
        if expected_return is None or risk is None or risk == 0:
            return None
        
        return abs(expected_return / risk)
    
    def mark_executed(self, execution_price: float, execution_time: datetime) -> None:
        """
        Mark the signal as executed.
        
        Args:
            execution_price: Actual price at which the trade was executed
            execution_time: Timestamp of trade execution
        """
        self.is_executed = True
        self.execution_price = execution_price
        self.execution_time = execution_time
        
        logger.info(f"Signal executed: {self.symbol} {self.signal_type.value} "
                   f"@ {execution_price} (target: {self.price})")
    
    def get_slippage(self) -> Optional[float]:
        """
        Calculate slippage between target and execution price.
        
        Returns:
            Slippage as a percentage, or None if not executed
        """
        if not self.is_executed or self.execution_price is None:
            return None
        
        return ((self.execution_price - self.price) / self.price) * 100
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary representation."""
        return {
            'symbol': self.symbol,
            'signal_type': self.signal_type.value,
            'timestamp': self.timestamp.isoformat(),
            'price': self.price,
            'position_size': self.position_size,
            'confidence': self.confidence,
            'strength': self.strength.value,
            'stop_loss': self.stop_loss,
            'take_profit': self.take_profit,
            'expiry': self.expiry.isoformat() if self.expiry else None,
            'strategy_name': self.strategy_name,
            'reason': self.reason,
            'metadata': self.metadata,
            'is_executed': self.is_executed,
            'execution_price': self.execution_price,
            'execution_time': self.execution_time.isoformat() if self.execution_time else None
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Signal':
        """Create Signal object from dictionary representation."""
        # Convert string timestamps back to datetime objects
        timestamp = datetime.fromisoformat(data['timestamp'])
        expiry = datetime.fromisoformat(data['expiry']) if data.get('expiry') else None
        execution_time = datetime.fromisoformat(data['execution_time']) if data.get('execution_time') else None
        
        # Convert enum values
        signal_type = SignalType(data['signal_type'])
        strength = SignalStrength(data['strength'])
        
        return cls(
            symbol=data['symbol'],
            signal_type=signal_type,
            timestamp=timestamp,
            price=data['price'],
            position_size=data['position_size'],
            confidence=data['confidence'],
            strength=strength,
            stop_loss=data.get('stop_loss'),
            take_profit=data.get('take_profit'),
            expiry=expiry,
            strategy_name=data.get('strategy_name', ''),
            reason=data.get('reason', ''),
            metadata=data.get('metadata', {}),
            is_executed=data.get('is_executed', False),
            execution_price=data.get('execution_price'),
            execution_time=execution_time
        )
    
    def __str__(self) -> str:
        """String representation of the signal."""
        return (f"{self.signal_type.value.upper()} {self.symbol} @ {self.price:.2f} "
                f"(size: {self.position_size:.3f}, conf: {self.confidence:.2f})")
    
    def __repr__(self) -> str:
        """Detailed string representation of the signal."""
        return (f"Signal(symbol='{self.symbol}', type={self.signal_type.value}, "
                f"price={self.price:.2f}, size={self.position_size:.3f}, "
                f"confidence={self.confidence:.2f})")